use std::str::FromStr;
use swindle::ast::*;
use swindle::error::*;

grammar;

pub Program: Program<Parsed> = {
    ";"* <statements:TaggedStatement*> => Program { statements }
}

TaggedStatement: TaggedStatement<Parsed> = {
    <tag:FP> <statement:SemiStatement> => TaggedStatement { tag, statement }
}

Statement: Statement<Parsed> = {
    <t:Type> <v:Variable> "=" <e:Expression> => Statement::Declare(t, v, Box::new(e)),
    "break" => Statement::Break,
    "continue" => Statement::Continue,
    <e:Expression> => Statement::Expression(Box::new(e)),
}

SemiStatement: Statement<Parsed> = {
    <stmt:Statement> ";"+ => stmt
}

Type: Type = {
    "int" => Type::Int,
    "string" => Type::String,
    "bool" => Type::Bool,
    "unit" => Type::Unit,
    "[" <typ:Type> "]" => Type::List(Box::new(typ)),
}

Expression: Expression<Parsed> = {
    <v:Variable> "=" <e:Expression> => Expression::Assign((), v, Box::new(e)),
    <o:OrExp> => Expression::OrExp(Box::new(o)),
}

OrExp: OrExp<Parsed> = {
    <a:AndExp> "or" <o:OrExp> => OrExp::Or(Box::new(a), Box::new(o)),
    <a:AndExp> => OrExp::AndExp(Box::new(a)),
}

AndExp: AndExp<Parsed> = {
    <c:CompExp> "and" <a:AndExp> => AndExp::And(Box::new(c), Box::new(a)),
    <c:CompExp> => AndExp::CompExp(Box::new(c)),
}

CompExp: CompExp<Parsed> = {
    <a1:AddExp> "<=" <a2:AddExp> => CompExp::Comp(CompOp::Leq, Box::new(a1), Box::new(a2)),
    <a1:AddExp> "<" <a2:AddExp> => CompExp::Comp(CompOp::Lt, Box::new(a1), Box::new(a2)),
    <a1:AddExp> "==" <a2:AddExp> => CompExp::Comp(CompOp::Eq(()), Box::new(a1), Box::new(a2)),
    <a1:AddExp> "!=" <a2:AddExp> => {
        let eq = CompExp::Comp(CompOp::Eq(()), Box::new(a1), Box::new(a2));
        let and = AndExp::CompExp(Box::new(eq));
        let or = OrExp::AndExp(Box::new(and));
        let expression = Expression::OrExp(Box::new(or));
        let paren = Primary::Paren(Box::new(expression));
        let unary = Unary::Primary(Box::new(paren));
        let not = Unary::Not(Box::new(unary));
        let mul = MulExp::Unary(Box::new(not));
        let add = AddExp::MulExp(Box::new(mul));
        CompExp::AddExp(Box::new(add))
    },
    <a1:AddExp> ">=" <a2:AddExp> => CompExp::Comp(CompOp::Leq, Box::new(a2), Box::new(a1)),
    <a1:AddExp> ">" <a2:AddExp> => CompExp::Comp(CompOp::Lt, Box::new(a2), Box::new(a1)),
    <a:AddExp> => CompExp::AddExp(Box::new(a)),
}

AddExp: AddExp<Parsed> = {
    <m:MulExp> <op:AddOp> <a:AddExp> => AddExp::Add(op, Box::new(m), Box::new(a)),
    <m:MulExp> => AddExp::MulExp(Box::new(m)),
}

AddOp: AddOp<Parsed> = {
    "+" => AddOp::Sum(()),
    "-" => AddOp::Difference,
}

MulExp: MulExp<Parsed> = {
    <u:Unary> <op:MulOp> <m:MulExp> => MulExp::Mul(op, Box::new(u), Box::new(m)),
    <u:Unary> => MulExp::Unary(Box::new(u)),
}

MulOp: MulOp = {
    "*" => MulOp::Product,
    "/" => MulOp::Quotient,
    "%" => MulOp::Remainder,
}

Unary: Unary<Parsed> = {
    "-" <u:Unary> => Unary::Negate(Box::new(u)),
    "not" <u:Unary> => Unary::Not(Box::new(u)),
    <p:Primary> => Unary::Primary(Box::new(p)),
}

Primary: Primary<Parsed> = {
    "(" <e:Expression> ")" => Primary::Paren(Box::new(e)),
    <s:Str> => Primary::StringLit(s),
    <n:Num> => Primary::IntLit(n),
    <v:Variable> => Primary::Variable(v),
    "unit" => Primary::Unit,
    "true" => Primary::BoolLit(true),
    "false" => Primary::BoolLit(false),
    "while" <cond:Expression> <body:Body> => {
        Primary::WhileExp(WhileExp { tag: (), cond: Box::new(cond), body })
    },
    "if" <cond:Expression> <body:Body> <elifs:Elif*> <els:Els> => {
        Primary::IfExp(
            IfExp {
                tag: (),
                cond: Box::new(cond),
                body,
                elifs,
                els,
            }
        )
    },
    <body:Body> => Primary::StatementExp(body),
    <p:Primary> "[" <e:Expression> "]" => Primary::Index((), Box::new(p), Box::new(e)),
    <b:Builtin> "(" <args:Args> ")" => Primary::Builtin((b, args)),
}

Args: Vec<Expression<Parsed>> = {
    <e:Expression> => vec![e],
    <mut args:Args> "," <e:Expression> => {
        args.push(e);
        args
    },
    => Vec::new(),
}

Elif: Elif<Parsed> = {
    "elif" <cond:Expression> <body:Body> => Elif { cond: Box::new(cond), body }
}

Els: Body<Parsed> = {
    <els:_Els?> => match els { Some(els) => els, None => Body { statements: Vec::new() } },
}

_Els: Body<Parsed> = {
    "else" <body:Body> => body,
}

Body: Body<Parsed> = {
    "{" ";"* <statements:TaggedStatement*> "}" => Body { statements }
}

FP: FilePosition = {
    <l:@L> <r:@R> => FilePosition { line: l, column: r }
}

Str: String = <s:r#""(\\.|[^"\\])*""#> => {
    let mut str = String::new();
    let mut chars = s.chars();
    while let Some(c) = chars.next() {
        match c {
            '"' => continue,
            '\\' => match chars.next() {
                Some('"') => str.push('"'),
                Some('n') => str.push('\n'),
                Some('t') => str.push('\t'),
                _ => panic!(),
            }
            _ => str.push(c),
        }
    }
    str
};
Num: u64 = <s:r"[0-9]+"> => u64::from_str(s).unwrap();
Variable: String = <s:r"[a-zA-Z][_a-zA-Z0-9]*"> => s.to_string();
Builtin: String = <s:r"@[_a-zA-Z0-9]+"> => s.to_string();
